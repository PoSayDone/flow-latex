\section{Разработка приложения}

В этой части работы, мы рассмотрим процесс реализации приложения, начиная серверной частью и заканчивая клиентской.

По итогу мы получим клиент-серверное приложение написанное на языках JavaScript и Python, а так же проведем тестирование разработанного программного обеспечения.

\subsection{Серверная часть}

Серверная часть будет отвечать за работу с базой данных и за работу с клиентской частью -- она будет выполнять запросы отправленные с клиента, получать имеющиеся данные из базы данных или добавлять новые данные, а затем отправлять ответ на клиентскую часть.

\subsubsection{Создание базы данных}

За создание и работу с базой данных будет отвечать ORM sqlalchemy2. Данный позволяет легко создавать таблицы в sql базах данных на основе моделей написанных на python, а также позволяет легко делать запросы при помощи встроенных в него функций.

Код для создания таблиц представлен в ПРИЛОЖЕНИИ \ref{pril:db-models}.

\subsubsection{СRUD-операции}

Первым делом были написаны CRUD (create, read, update, delete) запросы для всех таблиц: Пользователи, Сообщения, Интересы, Цели поездок, Отправлений и Прибытий. Часть CRUD запросов представлена на рисунке \ref{crud-requests}.

\image{crud-requests}{Запросы в инструменте Swagger}{0.8}

\subsubsection{Авторизация}

Следующим этапом стало добавление авторизации. Для авторизации будем пользваться стандартом JSON Web Token (далее JWT). Он используется для передачи данных для аутентификации.

При авторизации или регистрации пользователю будет выдаваться два токена: access и refresh. Два токена нужно в целях безопасности.

Access токен, нужен для того, чтобы подтвердить является ли человек тем, за кого себя выдает. Этот токен подписывается на сервере и на сервере же проверятся является ли он действительным. Время жизни Access токена ограничено и в нашем случае будет 30 минут.

Refresh токен, он отвечает за выпуск нового access токена, база данных будет хранить пару id пользователя и refresh для каждого авторизованного пользователя. При получении запроса на обновление access токена, сервер сверяет refresh токен из запроса и refresh токен пользователя из базы данных, если он совпадают, сервер отправляет новую пару токенов.

Диаграммы запросов входа, регистрации и обновления токенов представлены на рисунках с \ref{login-diagram} по \ref{refresh-diagram}.

На рисунке \ref{login-diagram} представлена диаграмма входа пользователя. Запрос работает так:
\begin{enumerate}
    \item Пользователь вводит почту и пароль в форму на клиентской части.
    \item Клиент отправляет данные пользователя на сервер.
    \item Сервер сверяет пароль с тем, что хранится в базе данных.
    \item Если пароль верный, то сервер отправляет пару ключей.
\end{enumerate}

\image{login-diagram}{Диаграмма входа}{0.8}

На рисунке \ref{registration-diagram} представлена диаграмма регистрации пользователя. Запрос работает так:
\begin{enumerate}
    \item Пользователь вводит данные для создания аккаунта.
    \item Сервер записывает данные в базу данных.
    \item Сервер отправляет пару ключей.
\end{enumerate}
\image{registration-diagram}{Диаграмма регистрации}{0.8}


На рисунке \ref{refresh-diagram} представлена диаграмма обновления access токена. Запрос работает так:
\begin{enumerate}
    \item Сервер берет access и refresh токены из http-only cookie.
    \item Сервер проверяет правильность refresh токена.
    \item Если refresh токен правильный, то сервер отправляет новую пару ключей и обновляет refresh токен пользователя в базе данных.
\end{enumerate}
\image{refresh-diagram}{Диаграмма обновления токена}{0.8}


\subsubsection{Обмен сообщениями}

Далее было решено приступить к реализации обмена сообщениями. Для решения это задачи можно использовать несколько способов.

\begin{itemize}
    \item SSE (Server Side Events), формируется соединение от сервера к клиенту, клиент может получать только сигналы от сервера, сам клиент не может отправлять сигналы;
    \item WebSockets, отдельный сервер, сигналы могут отправлять и клиент и сервер;
    \item long polling, на сервер отправляется запрос, который может длиться длительное время и завершиться только когда, сервер ответит.
\end{itemize}

Все варианты имеют свои плюсы и минусы, наверное кроме long polling, сложно представить где этот метод можно применить, так как его скорее можно назвать "костылём" при наличии других методов.

В реализации приложения было решено использовать WebSockets, а точнее сервис <<Pusher>>, который предоставляет максимально простое api для работы. Схема работы с <<Pusher>> представлена на рисунке \ref{pusher-diagram}.

\image{pusher-diagram}{Диаграмма взаимодействия с сервером <<Pusher>>}{0.8}

При создании чата и при добавлении нового сообщения в базу данных сервер отправляет сигнал на сервер <<Pusher>>, он же в свою очередь отправляет сигнал на подключенный к <<Pusher>> клиент, который обрабатывает пришедшие на него сигналы.

\subsection{Серверная часть}

Серверная часть будет отвечать за работу с базой данных и за работу с клиентской частью -- она будет выполнять запросы отправленные с клиента, получать имеющиеся данные из базы данных или добавлять новые данные, а затем отправлять ответ на клиентскую часть.

\subsubsection{Создание базы данных}

За создание и работу с базой данных будет отвечать ORM sqlalchemy2. Данный позволяет легко создавать таблицы в sql базах данных на основе моделей написанных на python, а также позволяет легко делать запросы при помощи встроенных в него функций.

Код для создания таблиц представлен в ПРИЛОЖЕНИИ \ref{pril:db-models}.

Следует обратить внимание, что пользователю мы добавляем отношения с сообщениями, диалогами, интересами, целями поездок, отправлениями и прибытиями -- это нужно для того, чтобы упростить нам задачу написания запросов. При работе с любой из этих таблиц, вместо того, чтобы искать в каждом запросе эти данные для каждого конкретного пользователя, мы просто можем обратиться к полю с нужными нами данными в самом пользователе избегая этих шагов.

\subsubsection{СRUD-операции}

Первым делом были написаны CRUD (create, read, update, delete) запросы для всех таблиц: Пользователи, Сообщения, Интересы, Цели поездок, Отправлений и Прибытий. Часть CRUD запросов представлена на рисунке \ref{crud-requests}.

\image{crud-requests}{Запросы в инструменте Swagger}{0.8}

\subsubsection{Авторизация}

Следующим этапом стало добавление авторизации. Для авторизации будем пользваться стандартом JSON Web Token (далее JWT). Он используется для передачи данных для аутентификации.

При авторизации или регистрации пользователю будет выдаваться два токена: access и refresh. Два токена нужно в целях безопасности.

Access токен, нужен для того, чтобы подтвердить является ли человек тем, за кого себя выдает. Этот токен подписывается на сервере и на сервере же проверятся является ли он действительным. Время жизни Access токена ограничено и в нашем случае будет 30 минут.

Refresh токен, он отвечает за выпуск нового access токена, база данных будет хранить пару id пользователя и refresh для каждого авторизованного пользователя. При получении запроса на обновление access токена, сервер сверяет refresh токен из запроса и refresh токен пользователя из базы данных, если он совпадают, сервер отправляет новую пару токенов.

Диаграммы запросов входа, регистрации и обновления токенов представлены на рисунках с \ref{login-diagram} по \ref{refresh-diagram}.

На рисунке \ref{login-diagram} представлена диаграмма входа пользователя. Запрос работает так:
\begin{enumerate}
    \item Пользователь вводит почту и пароль в форму на клиентской части.
    \item Клиент отправляет данные пользователя на сервер.
    \item Сервер сверяет пароль с тем, что хранится в базе данных.
    \item Если пароль верный, то сервер отправляет пару ключей.
\end{enumerate}

\image{login-diagram}{Диаграмма входа}{0.8}

На рисунке \ref{registration-diagram} представлена диаграмма регистрации пользователя. Запрос работает так:
\begin{enumerate}
    \item Пользователь вводит данные для создания аккаунта.
    \item Сервер записывает данные в базу данных.
    \item Сервер отправляет пару ключей.
\end{enumerate}
\image{registration-diagram}{Диаграмма регистрации}{0.8}


На рисунке \ref{refresh-diagram} представлена диаграмма обновления access токена. Запрос работает так:
\begin{enumerate}
    \item Сервер берет access и refresh токены из http-only cookie.
    \item Сервер проверяет правильность refresh токена.
    \item Если refresh токен правильный, то сервер отправляет новую пару ключей и обновляет refresh токен пользователя в базе данных.
\end{enumerate}
\image{refresh-diagram}{Диаграмма обновления токена}{0.8}


\subsubsection{Обмен сообщениями}

Далее было решено приступить к реализации обмена сообщениями. Для решения это задачи можно использовать несколько способов.

\begin{itemize}
    \item SSE (Server Sent Events), формируется соединение от сервера к клиенту, клиент может получать только сигналы от сервера, сам клиент не может отправлять сигналы;
    \item WebSockets, отдельный сервер, сигналы могут отправлять и клиент и сервер;
    \item long polling, на сервер отправляется запрос, который может длиться длительное время, а при превышении лимита времени отправится снова, завершиться только когда, сервер ответит, после этого сразу же отправится новый запрос.
\end{itemize}

Все варианты имеют свои плюсы и минусы, наверное кроме long polling, данный  метод можно использовать только за не имением первых двух, так как он повышает нагрузку на сервер, постоянно посылая запросы.

В реализации приложения было решено использовать WebSockets, а точнее сервис <<Pusher>>, который предоставляет максимально простое api для работы. Схема работы с <<Pusher>> представлена на рисунке \ref{pusher-diagram}.

\image{pusher-diagram}{Диаграмма взаимодействия с сервером <<Pusher>>}{0.8}

При создании чата и при добавлении нового сообщения в базу данных сервер отправляет сигнал на сервер <<Pusher>>, он же в свою очередь отправляет сигнал на подключенный к <<Pusher>> клиент, который обрабатывает пришедшие на него сигналы.

Пример вызова сигнала при помощи <<Pusher>> представлен ниже.

\codefromfile{pusher-example.py}{python}

\subsubsection{Запросы для форм}

В нашем клиентском приложении будет несколько форм, для них требуются отдельные запросы, так как они не попадают в CRUD операции реализованные ранее.

Например таким запросом будет являться форма изменения интересов, с клиента мы будем получать массив id интересов, на сервере мы должны заменить ими текущие.

\codefromfile{interests-edit.py}{python}

Так как мы добавили отношение с интересами в модель пользователя ранее, то для того, чтобы удалить текущие интересы пользователя, мы можем обратиться прямиком к текущему пользователю и заменить поле interests пустым массивом, для того чтобы удалить их. А затем в цикле мы добавляем в таблицу user\_interest все новые интересы.

Пользуясь такой логикой мы реализуем и другие формы, логика которых будет рассмотрена в части реализации клиентской части.
